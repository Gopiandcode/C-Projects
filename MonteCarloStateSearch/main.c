#include <stdio.h>
#include <stdarg.h>
#include <stdlib.h>
#include <assert.h>

#include <time.h>

#include "main.h"
#include "stateQueue.h"
#include <time.h>

int main()
{
    // Runs a test suite if TESTING == 1, to ensure code works
    unitTest();

    // Receive input from user, convert to compatible format.
    int start = getInput();

    // Set a reference time to measure the length of time the search takes
    clock_t timeStart = clock();

    // Run the full search.
    iterTest(start);

    clock_t diff = clock() - timeStart;
    int msec = diff * 1000 / CLOCKS_PER_SEC;


    fprintf(stdout, "Time taken: %d s %d ms\n", msec/1000, msec%1000);

    return 0;
}


void unitTest() {
    /* Main Unit Test declaration, prior to code */
    if (TESTING) {
        fprintf(stdout, "Testing Enabled, slowdown might be noticed. Note: input and output functions can not be tested.\n");

        /*StartState Tests*/
        int a[1] = {0};
        assert (startState(1, a) == 0b1000000000000000);
        a[0] = 2;
        assert (startState(1, a) == 0b0010000000000000);
        free(a);
        int b[4] = {0, 1, 2, 3};
        assert(startState(4, b) == 0b1111000000000000);
        free(b);

        /*checkCompatible Tests*/
        assert(checkCompatible(0b1111000000000000, 0) == 1);
        assert(checkCompatible(0b1111000000000000, 15) == 0);
        assert(checkCompatible(0b1111000000000001, 15) == 1);
        assert(checkCompatible(0, 8) == 0);


        /*queuetesting code*/
        head *testQueue = startQueue();
        assert(testQueue->length == 0);
        insertState(testQueue, 0, 1);
        assert(checkQueue(testQueue, 0) == 1);
        assert(retrieveState(testQueue) == 0);
        assert(testQueue->length == 0);
        insertState(testQueue, 1, 1);
        insertState(testQueue, 2, 2);
        assert(retrieveState(testQueue)== 1);
        assert(testQueue->length == 1);
        assert(retrieveState(testQueue)== 2);
        assert(testQueue->length == 0);
        insertState(testQueue, 1, 1);
        insertState(testQueue, 2, 8);
        insertState(testQueue, 4, 6);
        setWeight(testQueue, 2, 5);
        assert(retrieveState(testQueue)==1);
        assert(retrieveState(testQueue)==2);
        assert(retrieveState(testQueue)==4);
        free(testQueue);


        /*stateScore Tests*/
        assert(stateScore(0) == 0);
        assert(stateScore(1) == 1);
        assert(stateScore(3) == 2);
        assert(stateScore(4) == 1);
        assert(stateScore(0b0110000111000101) == 7);


        /*Rand position test */
        assert(randPos() < 16);
        assert(randPos() >= 0);
        assert(randPos() < 16);
        assert(randPos() >= 0);
        assert(randPos() < 16);
        assert(randPos() >= 0);

    }
}

// Given an input array of mole positions, returns a state representing that information.
int startState(int count, int *vals) {
    int i;
    int output = 0;
    int current, mask;

    // State generated by bit shifting a 1 to the desired position and then or-ing it onto the state
    for(i = 0; i<count; i++){
        mask = 1;
        if ((current = vals[i]) > 15) fprintf(stderr, "ERROR: Input Argument Greater than length of state\n"), assert(0==1);
        mask <<= (15-current);
        output |= mask;
    }


    return output;
}

// Given a position and a state returns 1 if there exits a mole there and 0 if no mole exists
int checkCompatible(int state, int position) {
    if(position > 15) fprintf(stderr, "ERROR: Input position greater than length of state\n");
    state >>= (15-position);
    if ((state & 1) == 1) return 1;
    else return 0;
}

// Given an input state, generates a maximum of 16 states, by sucessively hitting all moles,
// taking the value produced and storing it in priority queue.
// also an equivalent queue is made containing the position hit to reach that state.
void generateStates(int state, head* queue, head *positions) {
    int i, temp;
    for(i = 0; i< 16; i++) {
        if (checkCompatible(state, i)) {
            temp = weightState(state^stateMasks[i]);
            insertState(queue, state^stateMasks[i], temp);
            insertState(positions, i, temp);
        }
    }
}

// Generates a weight for each state, by randomly hitting the state a set number of times,
// counting the bits up afterwards and then returning a value proportional to that
int weightState(int state) {
    int i;
    int pos;

    for(i = 0; i < SAMPLESIZE; i++) {
        if(stateScore(state) == 0) return i;
        while(1) {
            pos = randPos();
            if(checkCompatible(state, pos)) {
                state ^= stateMasks[pos];
                break;
            }
        }
    }
    return(stateScore(state)*(i+1));
}

// Calculates an inherent score for each state by counting the number of moles up.
int stateScore(int state) {
    int count = 0;
    while (state != 0) {
        if((state&1) == 1) count++;
        state >>= 1;
    }

    return count;

}

// Custom random function to return a value between 0 and 15, repeatedly retrieves random values
// till one is obtained between 0 and 15 - modulo could be used, but it might affect the pseudo
// randomness distribution of the numbers
int randPos(void) {
    static int seed_set = 0;
    if (!seed_set) srand(time(NULL)), seed_set = 1;
    int r;

    while(1) {
        r = rand();
        if(r >= 0 && r < 16) return r;
    }

}

// Repeatedly generates states, selects the lowest weighted one till a solution is found.
head *monteCarlo(int state) {
    head *stateQueue = startQueue();
    head *positionQueue = startQueue();
    head *output = startQueue();

    int currentState = state;
    int count = 0;
    int i;
    int temp;
    while(stateScore(currentState) != 0) {

        generateStates(currentState, stateQueue, positionQueue);
        insertState(output, retrieveState(positionQueue), count);
        currentState = retrieveState(stateQueue);
        temp = stateQueue->length;
        for(i = 0; i< temp; i++) retrieveState(stateQueue);
        temp = positionQueue->length;
        for(i = 0; i< temp; i++) retrieveState(positionQueue);
        count++;

        if (count > MAXLENGTH) {
            currentState = state;
            count = 0;
            temp = output->length;
            for(i = 0; i< temp; i++) retrieveState(output);
        }


    }
    free(stateQueue);
    free(positionQueue);

    return output;
}

// Repeatedly runs the montecarlo search to increase the probability of achieving a small solution
void iterTest(int state) {
    int length = MAXLENGTH;
    int i, j;
    head *testStates;
    printBin(state);
    for(i = 0; i<OUTPUTTEST; i++) {
        testStates = monteCarlo(state);
        if(testStates->length < length) {
            altPrintQueue(testStates);
            length = testStates->length;
            fprintf(stdout, "\n\n");
        }

        for(j = 0; j < testStates->length; j++) retrieveState(testStates);

    }
}


/*Input Functions, non technical or fun, so left to the end*/

// Mostly debug, given a binary representation of a state, prints it in such a way
// such that the parallels between the representation and the state are clear.
void printBin(int n) {
    int ref = n;
    int counter;
    for(counter = 0; counter < 16; counter++) {
        if(((ref >> (15 - counter)) & 1) == 1) fprintf(stdout, "1");
        else fprintf(stdout, "0");
        if((counter+1)%4 == 0) fprintf(stdout, "\n");
    }
    fprintf(stdout, "\n");
}

// Does what it says on the tin.
int getInput(void) {
    int num, i;
    int *vals;
    fprintf(stdout, "Enter the number of moles in the initial state:");
    fscanf(stdin, "%d", &num);
    vals = malloc(sizeof(int)*num);
    fprintf(stdout, "Enter the nodes:");
    for(i = 0; i<num; i++) {
        fscanf(stdin, "%d", vals+i);
    }
    for(i = 0; i<num; i++) {
        *(vals+i) = convToBad(*(vals+i));
    }
    return startState(num, vals);

}



// Small adjustment process, added at last second, possibly not the most efficient,
// the problem for which this program was designed, names' it's boards in an odd manner.
int convToGood(int badRef) {
    int goodRef;
    switch(badRef) {
    case 0:
        goodRef = 13;
        break;
    case 1:
        goodRef = 14;
        break;
    case 2:
        goodRef = 15;
        break;
    case 3:
        goodRef = 16;
        break;
    case 4:
        goodRef = 9;
        break;
    case 5:
        goodRef = 10;
        break;
    case 6:
        goodRef = 11;
        break;
    case 7:
        goodRef = 12;
        break;
    case 8:
        goodRef = 5;
        break;
    case 9:
        goodRef = 6;
        break;
    case 10:
        goodRef = 7;
        break;
    case 11:
        goodRef = 8;
        break;
    case 12:
        goodRef = 1;
        break;
    case 13:
        goodRef = 2;
        break;
    case 14:
        goodRef = 3;
        break;
    case 15:
        goodRef = 4;
        break;
    default:
        fprintf(stderr, "Error: invalid conversion attempted\n");
        exit(1);
    }
    return goodRef;
}


int convToBad(int goodRef) {
    int badRef;
    switch(goodRef) {
    case 13:
        badRef = 0;
        break;
    case 14:
        badRef = 1;
        break;
    case 15:
        badRef = 2;
        break;
    case 16:
        badRef = 3;
        break;
    case 9:
        badRef = 4;
        break;
    case 10:
        badRef = 5;
        break;
    case 11:
        badRef = 6;
        break;
    case 12:
        badRef = 7;
        break;
    case 5:
        badRef = 8;
        break;
    case 6:
        badRef = 9;
        break;
    case 7:
        badRef = 10;
        break;
    case 8:
        badRef = 11;
        break;
    case 1:
        badRef = 12;
        break;
    case 2:
        badRef = 13;
        break;
    case 3:
        badRef = 14;
        break;
    case 4:
        badRef = 15;
        break;
    default:
        fprintf(stderr, "Error: invalid conversion attempted\n");
        exit(1);
    }
    return badRef;
}

